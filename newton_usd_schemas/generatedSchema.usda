#usda 1.0
(
)

class NewtonSceneAPI "NewtonSceneAPI" (
    doc = "NewtonSceneAPI applies on top of a PhysicsScene Prim, providing attributes to control a Newton Solver."
)
{
    uniform int newton:maxSolverIterations = -1 (
        doc = """Maximum number of iterations of the physics solver.

        If set to -1, each solver is free to choose an appropriate default.

        Range: [-1, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                int minimum = -1
            }
        }
    )

    uniform int newton:timeStepsPerSecond = 1000 (
        doc = """Simulation time step frequency in Hz.

        Range: [1, inf)
        Units: hertz"""
        limits = {
            dictionary hard = {
                int minimum = 1
            }
        }
    )

    bool newton:gravityEnabled = true (
        doc = """Whether gravity should be enabled or disabled in the simulation.

        This is intentionally separated from the gravity direction and magnitude
        to allow temporary disabling of gravity without modifying & caching values.
        """
    )
}

class "NewtonXpbdSceneAPI" (
    apiSchemas = ["NewtonSceneAPI"]
    doc = "Provides Newton's XPBD (eXtended Position-Based Dynamics) solver configuration."
)
{
    uniform float newton:xpbd:softBodyRelaxation = 0.9 (
        doc = """Relaxation multiplier for tetrahedral FEM constraint corrections.
        
        Scales the computed position correction for tetrahedral soft body constraints.
        Lower values improve stability but require more iterations for convergence.
        
        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:xpbd:softContactRelaxation = 0.9 (
        doc = """Relaxation multiplier for soft contact constraint corrections.
        
        Scales the computed position correction for particle-particle and particle-shape
        contacts. Lower values improve stability but require more iterations for convergence.
        
        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:xpbd:jointLinearRelaxation = 0.7 (
        doc = """Relaxation multiplier for joint linear constraint corrections.
        
        Scales the computed position correction for joint linear (positional) constraints.
        Lower values improve stability for complex kinematic chains but slow convergence.
        
        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:xpbd:jointAngularRelaxation = 0.4 (
        doc = """Relaxation multiplier for joint angular constraint corrections.
        
        Scales the computed rotation correction for joint angular (rotational) constraints.
        Lower values improve stability but slow convergence.
        
        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:xpbd:jointLinearCompliance = 0.0 (
        doc = """Compliance for joint linear constraints.
        
        Inverse stiffness for joint linear constraints. Added to denominator in constraint
        solver. Zero creates rigid constraints. Higher values create softer, springy joints.
        
        Range: [0, inf)
        Units: second * second / mass"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )

    uniform float newton:xpbd:jointAngularCompliance = 0.0 (
        doc = """Compliance for joint angular constraints.
        
        Inverse stiffness for joint angular constraints. Added to denominator in constraint
        solver. Zero creates rigid constraints. Higher values create softer, springy joints.
        
        Range: [0, inf)
        Units: degrees * second * second / (mass * distance * distance)"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )

    uniform float newton:xpbd:rigidContactRelaxation = 0.8 (
        doc = """Relaxation multiplier for rigid body contact constraint corrections.
        
        Scales the computed correction for rigid body contacts including normal, friction,
        torsional friction, and rolling friction. Lower values improve stability for
        stacking but require more iterations.
        
        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform bool newton:xpbd:rigidContactConWeighting = true (
        doc = """Enable contact constraint weighting for rigid bodies.
        
        When enabled, tracks the number of contacts per body and uses this information
        to distribute contact corrections more evenly across multiple simultaneous contacts."""
    )

    uniform float newton:xpbd:angularDamping = 0.0 (
        doc = """Angular velocity damping coefficient.
        
        Applied during rigid body integration as velocity *= (1 - damping * dt). Higher
        values cause rotational motion to decay faster.
        
        Range: [0, inf)
        Units: 1 / seconds"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )

    uniform bool newton:xpbd:restitutionEnabled = false (
        doc = """Whether restitution is enabled for contacts.
        
        When enabled, applies velocity corrections after constraint solving to simulate
        elastic collisions. Restitution coefficients are read from material properties."""
    )
}

class NewtonArticulationRootAPI "NewtonArticulationRootAPI" (
    apiSchemas = ["PhysicsArticulationRootAPI"]
    doc = """NewtonArticulationRootAPI extends the `PhysicsArticulationRootAPI` with additional attributes for Newton.
    
    By applying this schema, the prim also inherits the `PhysicsArticulationRootAPI` schema."""
)
{
    bool newton:selfCollisionEnabled = true (
        doc = """Whether self collisions should be enabled or disabled for the entire articulation.

        When disabled, this is equivalent to applying `PhysicsFilteredPairsAPI` relationships between all bodies in the articulation."""
    )
}

class NewtonCollisionAPI "NewtonCollisionAPI" (
    apiSchemas = ["PhysicsCollisionAPI"]
    doc = """NewtonCollisionAPI applies on top of a Gprim, providing extra collision attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsCollisionAPI` schema."""
)
{
    float newton:contactMargin = 0 (
        doc = """Outward offset/inflation of the shape's surface for collision detection.

        Extends/inflates the effective collision surface outward by this amount. When two shapes collide,
        their contact margins are summed (`margin_a + margin_b`) to determine the total separation/penetration.
        
        Range: [0, inf)
        Units: distance"""
        limits = {
            dictionary soft = {
                float minimum = 0
            }
        }
    )
    float newton:contactGap = -inf (
        doc = """Distance threshold below which contacts are detected.

        AABBs are expanded by this value and potential contact points get added into the solver
        once their separation is smaller than the contact gap sum (`gap_a + gap_b`).

        If `newton:contactGap` is set to `-inf`, the contact gap is assumed to match `newton:contactMargin`,
        ensuring collisions are not missed when inflated surfaces approach each other.

        Range: [-inf, inf)
        Units: distance"""
    )
}

class NewtonMeshCollisionAPI "NewtonMeshCollisionAPI" (
    apiSchemas = ["NewtonCollisionAPI", "PhysicsMeshCollisionAPI"]
    doc = """NewtonMeshCollisionAPI applies on top of a Mesh, providing extra mesh collision attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsCollisionAPI`, `NewtonCollisionAPI` and `PhysicsMeshCollisionAPI` schemas."""
)
{
    uniform int newton:maxHullVertices = -1 (
        doc = """Maximum number of vertices in the resulting convex hull approximation.

        This value is only relevant when `physics:approximation = "convexHull"`.

        If `newton:maxHullVertices` is set to -1, the hull computation should use as many vertices as necessary to produce a perfect convex hull.

        Range: [-1, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                int minimum = -1
            }
        }
    )
}

class NewtonMaterialAPI "NewtonMaterialAPI" (
    apiSchemas = ["PhysicsMaterialAPI"]
    doc = """NewtonMaterialAPI applies on top of a Material, providing extra physical material attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsMaterialAPI` schema."""
)
{
    float newton:torsionalFriction = 0.25 (
        doc = """Torsional friction coefficient (resistance to spinning at a contact point).

        Range: [0, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )

    float newton:rollingFriction = 0.0005 (
        doc = """Rolling friction coefficient (resistance to rolling motion).

        Range: [0, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )
}

class NewtonMimicAPI "NewtonMimicAPI" (
    doc = """NewtonMimicAPI applies on top of a PhysicsJoint, adding additional constraints to mimic the DOFs of another joint.

    A mimic constraint enforces that `joint0 = coef0 + coef1 * joint1` for the joint DOFs,
    where `joint0` is this joint (the follower) and `joint1` (the leader) is specified via the `newton:mimicJoint` relationship.

    The behavior on multi-DOF joints is undefined. The mimic constraint will be applied to each DOF independently,
    but as the coefficients are shared across all DOFs, the units for translational and rotational DOFs will be mixed.
    Therefore, it is recommended to only use this API on single-DOF joints.
    """
)
{
    bool newton:mimicEnabled = true (
        doc = """Whether the mimic constraint is active.

        When disabled, the follower joint moves independently, as though the mimic constraint was not applied."""
    )

    rel newton:mimicJoint (
        doc = "Joint that will be mimicked."
    )

    float newton:mimicCoef0 = 0.0 (
        doc = """Offset added after scaling the leader joint's position/angle.

        In the mimic equation which constrains the joint DOFs, `joint0 = coef0 + coef1 * joint1`,
        this is the constant offset term.

        Range: (-inf, inf)
        Units: distance or degrees (matches the joint type for single-DOF joints)"""
    )

    float newton:mimicCoef1 = 1.0 (
        doc = """Scale factor applied to the leader joint's position/angle.

        In the mimic equation which constrains the joint DOFs, `joint0 = coef0 + coef1 * joint1`,
        this is the linear coefficient.

        A value of 1.0 means the follower tracks the leader exactly (plus offset from `newton:mimicCoef0`),
        while negative values reverse the direction.

        Range: (-inf, inf)
        Units: dimensionless"""
    )
}